<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>äº”å­æ£‹å°æ¸¸æˆ</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            touch-action: manipulation; /* é˜²æ­¢åŒå‡»ç¼©æ”¾ */
        }
        canvas {
            border: 2px solid #5d4037;
            border-radius: 4px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
            cursor: pointer;
            /* è®© Canvas åœ¨å°å±å¹•ä¸Šè‡ªåŠ¨ç¼©æ”¾ */
            max-width: 100%; 
            height: auto;
            background-color: #e0c39a;
        }
        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }
        .controls {
            display: flex;
            gap: 12px;
            align-items: center;
            font-size: 0.9rem;
            flex-wrap: wrap;
            justify-content: center;
        }
        .score-item {
            display: flex;
            align-items: center;
            gap: 8px;
            background: white;
            padding: 8px 12px;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.05);
            font-weight: bold;
        }
    </style>
</head>
<body class="bg-slate-100 min-h-screen flex items-center justify-center p-4">

    <div class="bg-white/90 backdrop-blur-md w-full max-w-3xl rounded-2xl shadow-2xl p-6 md:p-8 flex flex-col items-center text-slate-700">
        
        <h1 class="text-3xl font-bold mb-6 text-slate-800 flex items-center gap-3">
            <span class="bg-black text-white w-8 h-8 rounded-full flex items-center justify-center text-sm shadow-sm">é»‘</span>
            <span>äº”å­æ£‹å¯¹æˆ˜</span>
            <span class="bg-white border-2 border-slate-300 text-slate-500 w-8 h-8 rounded-full flex items-center justify-center text-sm shadow-sm">ç™½</span>
        </h1>
        
        <div class="game-container w-full">
            
            <!-- æ¸¸æˆä¿¡æ¯æ  -->
            <div id="statusInfo" class="text-lg font-bold text-blue-600 animate-pulse">
                è½®åˆ°é»‘æ£‹ (ç©å®¶) ä¸‹å­
            </div>

            <!-- æ¸¸æˆæ£‹ç›˜ -->
            <!-- è¿™é‡Œè®¾ç½® width=600 æ˜¯å†…éƒ¨åˆ†è¾¨ç‡ï¼ŒCSSä¼šæ§åˆ¶å®ƒåœ¨å±å¹•ä¸Šçš„å®é™…å¤§å° -->
            <canvas id="gameCanvas" width="600" height="600"></canvas>

            <!-- æ§åˆ¶åŒº -->
            <div class="controls w-full">
                <!-- åˆ†æ•° -->
                <div class="score-item border-l-4 border-black">
                    ç©å®¶: <span id="playerScore">0</span>
                </div>
                <div class="score-item border-l-4 border-slate-400">
                    AI: <span id="computerScore">0</span>
                </div>

                <!-- éš¾åº¦é€‰æ‹© -->
                <div class="flex items-center bg-white px-3 py-2 rounded-lg shadow-sm">
                     <label for="difficulty" class="text-sm font-semibold mr-2">éš¾åº¦:</label>
                     <select id="difficulty" class="bg-slate-50 border border-slate-200 rounded text-sm p-1 outline-none focus:ring-2 focus:ring-blue-400">
                         <option value="easy">ç®€å• (å°ç™½)</option>
                         <option value="medium" selected>æ™®é€š (è¿›é˜¶)</option>
                         <option value="hard">å›°éš¾ (å¤§å¸ˆ)</option>
                     </select>
                </div>

                <!-- æŒ‰é’®ç»„ -->
                <button id="resetBtn" class="bg-slate-200 hover:bg-slate-300 text-slate-700 px-4 py-2 rounded-lg text-sm font-bold shadow-sm transition">
                    â™»ï¸ é‡ç½®åˆ†æ•°
                </button>
                <button id="rematchBtn" class="bg-blue-600 hover:bg-blue-700 text-white px-6 py-2 rounded-lg text-sm font-bold shadow-md transition transform active:scale-95">
                    âš”ï¸ å†æ¥ä¸€å±€
                </button>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const statusInfo = document.getElementById('statusInfo');
        const resetBtn = document.getElementById('resetBtn');
        const rematchBtn = document.getElementById('rematchBtn');
        const difficultySelect = document.getElementById('difficulty');
        const playerScoreDisplay = document.getElementById('playerScore');
        const computerScoreDisplay = document.getElementById('computerScore');

        // æ¸¸æˆé…ç½®
        const BOARD_SIZE = 15; 
        const CELL_SIZE = canvas.width / BOARD_SIZE;
        const BLACK = 1; // ç©å®¶
        const WHITE = 2; // AI
        
        let board = []; 
        let currentPlayer = BLACK;
        let gameOver = false;
        let playerScore = 0;
        let computerScore = 0;
        let aiLevel = 'medium'; 

        // --- æ ¸å¿ƒé€»è¾‘ï¼šåˆå§‹åŒ– ---
        function initBoard() {
            board = Array(BOARD_SIZE).fill(0).map(() => Array(BOARD_SIZE).fill(0));
            drawBoard();
            statusInfo.innerText = "è½®åˆ°é»‘æ£‹ (ç©å®¶) ä¸‹å­";
            statusInfo.className = "text-lg font-bold text-blue-600";
            gameOver = false;
            currentPlayer = BLACK;
        }

        // --- æ ¸å¿ƒé€»è¾‘ï¼šç»˜å›¾ ---
        function drawBoard() {
            // æ¸…ç©ºå¹¶å¡«å……èƒŒæ™¯
            ctx.fillStyle = '#e0c39a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // ç”»ç½‘æ ¼çº¿
            ctx.strokeStyle = '#5d4037';
            ctx.lineWidth = 1.5;
            
            for (let i = 0; i < BOARD_SIZE; i++) {
                // åæ ‡è®¡ç®—ï¼šæ ¼å­ä¸­å¿ƒçº¿
                const pos = CELL_SIZE / 2 + i * CELL_SIZE;
                
                // æ¨ªçº¿
                ctx.beginPath();
                ctx.moveTo(CELL_SIZE / 2, pos);
                ctx.lineTo(canvas.width - CELL_SIZE / 2, pos);
                ctx.stroke();

                // ç«–çº¿
                ctx.beginPath();
                ctx.moveTo(pos, CELL_SIZE / 2);
                ctx.lineTo(pos, canvas.height - CELL_SIZE / 2);
                ctx.stroke();
            }

            // ç”»â€œå¤©å…ƒâ€å’Œâ€œæ˜Ÿä½â€ (è£…é¥°ç‚¹)
            const stars = [3, 7, 11];
            ctx.fillStyle = '#5d4037';
            for(let r of stars) {
                for(let c of stars) {
                    ctx.beginPath();
                    ctx.arc(CELL_SIZE/2 + c*CELL_SIZE, CELL_SIZE/2 + r*CELL_SIZE, 3, 0, Math.PI*2);
                    ctx.fill();
                }
            }
            
            // ç»˜åˆ¶å·²è½çš„æ£‹å­
            for (let i = 0; i < BOARD_SIZE; i++) {
                for (let j = 0; j < BOARD_SIZE; j++) {
                    if (board[i][j] === BLACK) drawPiece(i, j, 'black');
                    else if (board[i][j] === WHITE) drawPiece(i, j, 'white');
                }
            }
        }

        function drawPiece(row, col, color) {
            const x = CELL_SIZE / 2 + col * CELL_SIZE;
            const y = CELL_SIZE / 2 + row * CELL_SIZE;
            const radius = CELL_SIZE / 2 * 0.8;

            ctx.beginPath();
            ctx.arc(x, y, radius, 0, Math.PI * 2);
            
            // åˆ¶ä½œç«‹ä½“æ„Ÿæ¸å˜
            const gradient = ctx.createRadialGradient(x - radius/3, y - radius/3, radius/10, x, y, radius);
            if (color === 'black') {
                gradient.addColorStop(0, '#666');
                gradient.addColorStop(1, '#000');
            } else {
                gradient.addColorStop(0, '#fff');
                gradient.addColorStop(1, '#ddd');
            }
            
            ctx.fillStyle = gradient;
            ctx.fill();
            
            // ç»™æ£‹å­åŠ ä¸€ç‚¹é˜´å½±
            ctx.shadowColor = 'rgba(0,0,0,0.5)';
            ctx.shadowBlur = 4;
            ctx.shadowOffsetX = 2;
            ctx.shadowOffsetY = 2;
            ctx.fill();
            ctx.shadowColor = 'transparent'; // é‡ç½®é˜´å½±
        }

        // --- äº¤äº’é€»è¾‘ï¼šä¿®æ­£åçš„ç‚¹å‡»äº‹ä»¶ ---
        canvas.addEventListener('mousedown', handleClick); // ä½¿ç”¨ mousedown ååº”æ›´å¿«

        function handleClick(event) {
            if (gameOver || currentPlayer !== BLACK) return;

            // 1. è·å– Canvas åœ¨å±å¹•ä¸Šçš„ç»å¯¹ä½ç½®å’Œå°ºå¯¸
            const rect = canvas.getBoundingClientRect();

            // 2. è®¡ç®—ç¼©æ”¾æ¯”ä¾‹ (å±å¹•åƒç´  vs Canvaså†…éƒ¨åƒç´ )
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;

            // 3. è®¡ç®—é¼ æ ‡åœ¨ Canvas å†…éƒ¨çš„åæ ‡
            const x = (event.clientX - rect.left) * scaleX;
            const y = (event.clientY - rect.top) * scaleY;

            // 4. è®¡ç®—è½å­ç½‘æ ¼åæ ‡ (å¸é™„ç®—æ³•)
            // (åæ ‡ - èµ·å§‹åç§») / æ ¼å­å¤§å°ï¼Œç„¶åå››èˆäº”å…¥
            const col = Math.round((x - CELL_SIZE / 2) / CELL_SIZE);
            const row = Math.round((y - CELL_SIZE / 2) / CELL_SIZE);

            // 5. è¾¹ç•Œä¸ç©ºä½æ£€æŸ¥
            if (row < 0 || row >= BOARD_SIZE || col < 0 || col >= BOARD_SIZE) return;
            
            if (board[row][col] === 0) {
                placeMove(row, col, BLACK);
            }
        }

        function placeMove(row, col, player) {
            board[row][col] = player;
            drawBoard();

            // æ£€æŸ¥èƒœè´Ÿ
            if (checkWin(row, col, player)) {
                endGame(player);
                return;
            }
            if (checkDraw()) {
                endGame(0);
                return;
            }

            // åˆ‡æ¢å›åˆ
            currentPlayer = currentPlayer === BLACK ? WHITE : BLACK;
            
            if (currentPlayer === WHITE) {
                statusInfo.innerText = "AI (ç™½æ£‹) æ€è€ƒä¸­...";
                statusInfo.className = "text-lg font-bold text-slate-500";
                // å»¶è¿Ÿæ‰§è¡Œ AIï¼Œé¿å…å¡é¡¿æ„Ÿ
                setTimeout(aiMove, 300);
            } else {
                statusInfo.innerText = "è½®åˆ°é»‘æ£‹ (ç©å®¶) ä¸‹å­";
                statusInfo.className = "text-lg font-bold text-blue-600";
            }
        }

        function endGame(winner) {
            gameOver = true;
            if (winner === BLACK) {
                statusInfo.innerText = "ğŸ‰ æ­å–œï¼ç©å®¶è·èƒœï¼";
                statusInfo.className = "text-xl font-bold text-green-600 animate-bounce";
                playerScore++;
            } else if (winner === WHITE) {
                statusInfo.innerText = "ğŸ¤– é—æ†¾ï¼ŒAI è·èƒœï¼";
                statusInfo.className = "text-xl font-bold text-slate-700";
                computerScore++;
            } else {
                statusInfo.innerText = "ğŸ¤ å¹³å±€ï¼";
                statusInfo.className = "text-xl font-bold text-gray-500";
            }
            updateScores();
        }

        // --- AI é€»è¾‘ ---
        function aiMove() {
            let move = null;
            if (aiLevel === 'easy') move = findBestMoveEasy();
            else if (aiLevel === 'medium') move = findBestMoveMedium();
            else move = findBestMoveHard();

            if (move) {
                placeMove(move[0], move[1], WHITE);
            } else {
                endGame(0); // æ— å¤„å¯ä¸‹
            }
        }

        // ç®€å• AI: éšæœº
        function findBestMoveEasy() {
            const moves = [];
            for (let r=0; r<BOARD_SIZE; r++)
                for (let c=0; c<BOARD_SIZE; c++)
                    if(board[r][c]===0) moves.push([r,c]);
            return moves.length > 0 ? moves[Math.floor(Math.random()*moves.length)] : null;
        }

        // æ™®é€š AI: è´ªå¿ƒç®—æ³•
        function findBestMoveMedium() {
            let bestMove = null;
            let maxScore = -Infinity;
            for (let r=0; r<BOARD_SIZE; r++) {
                for (let c=0; c<BOARD_SIZE; c++) {
                    if (board[r][c] === 0) {
                        // è¿›æ”» + é˜²å®ˆ
                        let score = evaluatePoint(r, c, WHITE) + evaluatePoint(r, c, BLACK) * 0.8;
                        if(score > maxScore) {
                            maxScore = score;
                            bestMove = [r, c];
                        }
                    }
                }
            }
            return bestMove || findBestMoveEasy();
        }

        // å›°éš¾ AI: ç®€å•çš„æå¤§æå°å€¼æ€æƒ³æ¨¡æ‹Ÿ
        function findBestMoveHard() {
             let bestMove = null;
            let maxScore = -Infinity;
            for (let r=0; r<BOARD_SIZE; r++) {
                for (let c=0; c<BOARD_SIZE; c++) {
                    if (board[r][c] === 0) {
                        // åŠ å¤§é˜²å®ˆæƒé‡ï¼Œå¹¶ä¸”ç¨å¾®çœ‹è¿œä¸€ç‚¹
                        let attack = evaluatePoint(r, c, WHITE);
                        let defense = evaluatePoint(r, c, BLACK);
                        
                        // å›°éš¾æ¨¡å¼ï¼šå¦‚æœç©å®¶æœ‰è¿ä¸‰ã€è¿å››ï¼Œå¿…é¡»é˜²å®ˆ
                        let score = attack + defense;
                        if (defense > 1000) score += 5000; // å¿…é¡»å µ
                        if (attack > 1000) score += 6000; // å¿…é¡»èµ¢

                        if(score > maxScore) {
                            maxScore = score;
                            bestMove = [r, c];
                        }
                    }
                }
            }
            return bestMove || findBestMoveMedium();
        }

        // è¯„ä¼°æŸä¸€ç‚¹çš„ä»·å€¼ (åŸºäºè¿å­æ•°é‡)
        function evaluatePoint(r, c, player) {
            let score = 0;
            const dirs = [[1,0], [0,1], [1,1], [1,-1]];
            
            // æ¨¡æ‹Ÿè½å­
            board[r][c] = player;
            
            for(let d of dirs) {
                let count = 1;
                // æ­£å‘æŸ¥æ‰¾
                for(let i=1; i<5; i++) {
                    let nr=r+d[0]*i, nc=c+d[1]*i;
                    if(nr<0||nr>=BOARD_SIZE||nc<0||nc>=BOARD_SIZE||board[nr][nc]!==player) break;
                    count++;
                }
                // åå‘æŸ¥æ‰¾
                for(let i=1; i<5; i++) {
                    let nr=r-d[0]*i, nc=c-d[1]*i;
                    if(nr<0||nr>=BOARD_SIZE||nc<0||nc>=BOARD_SIZE||board[nr][nc]!==player) break;
                    count++;
                }
                // æ‰“åˆ†è§„åˆ™
                if (count >= 5) score += 100000;
                else if (count === 4) score += 5000;
                else if (count === 3) score += 500;
                else if (count === 2) score += 50;
            }
            
            // æ’¤é”€æ¨¡æ‹Ÿ
            board[r][c] = 0;
            return score;
        }

        // --- èƒœè´Ÿåˆ¤æ–­ ---
        function checkWin(row, col, player) {
            const dirs = [[1,0], [0,1], [1,1], [1,-1]];
            for(let d of dirs) {
                let count = 1;
                for(let i=1; i<5; i++) {
                    let nr=row+d[0]*i, nc=col+d[1]*i;
                    if(nr<0||nr>=BOARD_SIZE||nc<0||nc>=BOARD_SIZE||board[nr][nc]!==player) break;
                    count++;
                }
                for(let i=1; i<5; i++) {
                    let nr=row-d[0]*i, nc=col-d[1]*i;
                    if(nr<0||nr>=BOARD_SIZE||nc<0||nc>=BOARD_SIZE||board[nr][nc]!==player) break;
                    count++;
                }
                if(count >= 5) return true;
            }
            return false;
        }

        function checkDraw() {
            return board.every(row => row.every(cell => cell !== 0));
        }

        function updateScores() {
            playerScoreDisplay.innerText = playerScore;
            computerScoreDisplay.innerText = computerScore;
        }

        // --- æŒ‰é’®äº‹ä»¶ ---
        resetBtn.addEventListener('click', () => {
            playerScore = 0;
            computerScore = 0;
            updateScores();
            initBoard();
        });

        rematchBtn.addEventListener('click', () => {
            initBoard();
        });

        difficultySelect.addEventListener('change', (e) => {
            aiLevel = e.target.value;
            // å¦‚æœæ¢éš¾åº¦æ—¶æ­£å¥½æ˜¯AIçš„å›åˆï¼Œè®©å®ƒé‡èµ°
            if(currentPlayer === WHITE && !gameOver) {
                aiMove();
            }
        });

        // å¯åŠ¨
        initBoard();

    </script>
</body>
</html>
